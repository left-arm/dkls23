# Multi-Party-TSS (ECDSA-DKLs23)

**Silent Shard** has been built using a cryptographic base of **Multiparty computation (MPC).** MPC enables a set of parties that do not trust each other to try to jointly compute a function (digital signature generation in this case) over their inputs (key shards in this case) while keeping those inputs privately stored with them. Threshold signatures are a case enabled by multiparty computation where a threshold number of parties, out of the previously agreed group of approving (participating) nodes, can compute a cryptographic digital signature. ECDSA is one type of such a signature scheme based on elliptic curves.

Threshold Signatures (TSS) scheme protocols are multi-step and interactive protocols built through cryptographic primitives and zero-knowledge proofs to generate an indistinguishable signature as generated by a wallet holding the private key in one place.

TSS consists of three stages:

- Distributed Key Generation (DKG),
- Distributed Signature Generation, and
- Proactive Security with Key rotation/refresh.

These functions involve cryptographic computing at the participating nodes of the MPC quorum and exchanges of rounds of messages which ultimately lead to the generation of a valid signature at the requested node. These computing nodes can be any device with sufficient computational and memory capability, including but not limited to smartphones, server nodes, and edge devices. The basic philosophy behind Silent Shard remains that no single device holding the private key can be used to generate signatures and move digital assets. The private key is shared among multiple computing nodes so that no party has any information about the key. Then, in order to generate a signature, the threshold number of devices run a secure two-party computation protocol that generates the signature without revealing anything about the parties' key shares to each other. These devices may or may not be associated with the same person or organization and can be any form factor. Thus, one could use this to create a wallet, sharing the private key between one's mobile and one's laptop, between one's mobile and a VM in the cloud, and so on.


# Articles and links
 - DKLs23 https://eprint.iacr.org/2023/765.pdf
 - DKG based on Protocol 6.1 https://eprint.iacr.org/2022/374.pdf
 - 1 out of 2 Endemic OT Fig.8 https://eprint.iacr.org/2019/706.pdf
 - All-but-one OTs from base OTs: Fig.13 and Fig.14 https://eprint.iacr.org/2022/192.pdf
 - Generation of *sent_seed_list* and *rec_seed_list* values ​​based on Protocol 2.2 Pairwise Randomization [dkls23_preprint.pdf](docs/dkls23_preprint.pdf)
 - SoftSpokenOT protocol https://eprint.iacr.org/2022/192.pdf
 - Instantiation of SoftSpokenOT based on Fig.10 https://eprint.iacr.org/2015/546.pdf
 - Proactive security definition, Section 2 https://www.iacr.org/archive/eurocrypt2006/40040601/40040601.pdf


# Protocol

Please note that the latest library of Silent Shard is based on DKLs23 TSS protocol.

# DKLs23

- Threshold ECDSA in Three Rounds: Now matches Schnorr.
- Enabled by well-chosen correlation + simple new consistency check.
- Blackbox use of UC 2-round 2P-MUL. It is to be noted that OT-based protocols satisfy UC, but AHE is more complicated.
- No (explicit) ZK proofs during signing or DKG; light protocol and straightforward UC analysis.

# Implementation of DKLs23 and related code

The cates in this repository uses create sl-mpc-mate and sl-oblivious
from [`sl-crypto`](https://gitlab.com/com.silencelaboratories/sl-crypto), and building with cargo will require the user to perform a `git pull` on that repository. If you don't have access, please contact a team member for help.

This stack is dockerised! We recommend reading this whole document for proper understanding, but if you just want to see how it runs you can skip to [this section](#run-an-example-of-the-full-system)



# Crates

The DKLs23 codebase has several components. All are necessary to ensure smooth operation, and the relationship between them is important to understand.

## dkls23-rs

This is the core crate, and handles the cryptographic heavy lifting. The main functions are:

```rust
// Distributed Key Generation
dkls23::keygen::dkg::run()

// Key Refresh
dkls23::keygen::key_refresh::run()

// Distributed Signature Generation
dkls23::sign::dsg::run()

// and methods for creating partial signatures and then combining them into a final signature:
dkls23::sign::dsg::pre_signature()
dkls23::sign::dsg::create_partial_signature()
dkls23::sign::dsg::combine_partial_signature()
```

Please refer to the cargo-generated documentation for information on their usage.

# Summary of Changes After Security Audit

## Setup Messages

The `run()` functions are now generic over the setup message type.
All setup message types must implement the trait
`ProtocolParticipant`, which contains associated types that define how
to sign and verify broadcast messages.

## Message Serialization

We implemented what we call zero-copy message serialization. We
redefined all messages sent between parties and their components to be
arrays of bytes. This transformation allows us to safely cast a byte
slice `&[u8]` into a reference to some message structure if the sizes
are equal.

This allows us to implement in-place message construction. We allocate
a memory buffer of an appropriate size, take a mutable reference to
some message structure, and pass it to a message constructor. Then we
calculate the message signature or encrypt the message in place
without any extra memory copying.

This provides not only memory efficiency but also more secure code
because we have exactly one copy of secret material in memory and
overwrite it with in-place encryption.

Key share representation also uses the same technique. We allocate a
memory buffer for the key share at the beginning of the key generation
execution and fill it piece by piece. This allows us to avoid extra
memory copies.

Key share for a 3-party case is about 130kb; messages are: 16kb, 37kb,
and 49kb.
